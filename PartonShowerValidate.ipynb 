{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 887
    },
    "colab_type": "code",
    "id": "oZ4uL4CKYwJ_",
    "outputId": "c20c6e38-b24c-49d0-c0ce-9cbe12eb5e8d"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "The following command must be run outside of the IPython shell:\n",
      "\n",
      "    $ pip install cirq\n",
      "\n",
      "The Python package manager (pip) can only be used from outside of IPython.\n",
      "Please reissue the `pip` command in a separate terminal or command prompt.\n",
      "\n",
      "See the Python documentation for more information on how to install packages:\n",
      "\n",
      "    https://docs.python.org/3/installing/\n"
     ]
    }
   ],
   "source": [
    "pip install cirq"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "86Gt5fYc-vYE"
   },
   "outputs": [],
   "source": [
    "import cirq\n",
    "import math\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from cirq import GridQubit, X, CNOT, TOFFOLI, ry\n",
    "early = cirq.InsertStrategy.EARLIEST\n",
    "new = cirq.InsertStrategy.NEW_THEN_INLINE"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "NUSsEaM3ffeX"
   },
   "source": [
    "helper for testing\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "fOPkslaffdLD"
   },
   "outputs": [],
   "source": [
    "def flatten(l):\n",
    "    \"\"\"\n",
    "    :param l: nested list of qubits in order given by fullReg\n",
    "    :return: return list of qubits in order of registers as given in qubit dictionary and from MSB to LSB.\n",
    "    This used to determine the order of qubits to display in the simulations results\n",
    "    For a qubit order [a,b], cirq will output in the form (sum |ab>)\n",
    "    \"\"\"\n",
    "    flatList = []\n",
    "    for i in l:\n",
    "        if isinstance(i, list):\n",
    "            flatList.extend(flatten(i))\n",
    "        else:\n",
    "            flatList.append(i)\n",
    "    return flatList"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "ename": "SyntaxError",
     "evalue": "invalid syntax (<ipython-input-6-c19a7d1668bd>, line 1)",
     "output_type": "error",
     "traceback": [
      "\u001b[0;36m  File \u001b[0;32m\"<ipython-input-6-c19a7d1668bd>\"\u001b[0;36m, line \u001b[0;32m1\u001b[0m\n\u001b[0;31m    print flatten(1)\u001b[0m\n\u001b[0m          ^\u001b[0m\n\u001b[0;31mSyntaxError\u001b[0m\u001b[0;31m:\u001b[0m invalid syntax\n"
     ]
    }
   ],
   "source": [
    "print flatten(1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "pTCE-D6YZnFi"
   },
   "source": [
    "## **Create Circuit**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "a2zMb3t8X93F"
   },
   "outputs": [],
   "source": [
    "# Define splitting functions and sudakov factors\n",
    "\n",
    "def P_f(t, g):\n",
    "    alpha = g**2 * Phat_f(t)/ (4 * math.pi)\n",
    "    return alpha\n",
    "\n",
    "def Phat_f(t):\n",
    "    return math.log(t)\n",
    "\n",
    "def Phat_bos(t):\n",
    "    return math.log(t)\n",
    "\n",
    "def Delta_f(t, g):\n",
    "    return math.exp(P_f(t,g))\n",
    "\n",
    "def P_bos(t, g_a, g_b):\n",
    "    alpha = g_a**2 * Phat_bos(t)/ (4 * math.pi) + g_b**2 * Phat_bos(t)/ (4 * math.pi)\n",
    "    return alpha\n",
    "\n",
    "def Delta_bos(t, g_a, g_b):\n",
    "    return math.exp(P_bos(t, g_a, g_b))\n",
    "\n",
    "\n",
    "def populateParameterLists(N, timeStepList, P_aList, P_bList, P_phiList, Delta_aList, Delta_bList, Delta_phiList, g_a,\n",
    "                           g_b, eps):\n",
    "    \"\"\"Populates the 6 lists with correct values for each time step theta\"\"\"\n",
    "    for i in range(N):\n",
    "        # Compute time steps\n",
    "        t_up = eps ** ((i) / N)\n",
    "        t_mid = eps ** ((i + 0.5) / N)\n",
    "        t_low = eps ** ((i + 1) / N)\n",
    "        timeStepList.append(t_mid)\n",
    "        # Compute values for emission matrices   \n",
    "        Delta_a = Delta_f(t_low, g_a)/ Delta_f(t_up, g_a)\n",
    "        Delta_b = Delta_f(t_low, g_b) / Delta_f(t_up, g_b)\n",
    "        Delta_phi = Delta_bos(t_low, g_a, g_b) / Delta_bos(t_up, g_a, g_b)\n",
    "        P_a, P_b, P_phi = P_f(t_mid, g_a), P_f(t_mid, g_b), P_bos(t_mid, g_a, g_b)\n",
    "\n",
    "        # Add them to the list\n",
    "        P_aList.append(P_a)\n",
    "        P_bList.append(P_b)\n",
    "        P_phiList.append(P_phi)\n",
    "        Delta_aList.append(Delta_a)\n",
    "        Delta_bList.append(Delta_b)\n",
    "        Delta_phiList.append(Delta_phi)\n",
    "\n",
    "def allocateQubs(N, n_i, L, pReg, hReg, w_hReg, eReg, wReg, n_aReg, w_aReg, n_bReg, w_bReg, n_phiReg, w_phiReg):\n",
    "    \"\"\"method 1: Pro: keeps qubits geometrically close (in rectangle), Con: Ordering is weird so hard to debug\"\"\"\n",
    "    pReg.extend([[GridQubit(i,j) for j in range(3)] for i in range(N+n_i)])\n",
    "    hReg.extend([[GridQubit(i,j) for j in range(4, 4+L)] for i in range(N)])\n",
    "    w_hReg.extend([GridQubit(N+n_i,j) for j in range(L-1)])\n",
    "    eReg.extend([GridQubit(N+n_i,L-1)])\n",
    "    wReg.extend([GridQubit(N+n_i,j) for j in range(L,L+5)])\n",
    "    n_phiReg.extend([GridQubit(N+n_i+1,j) for j in range(L)])\n",
    "    w_phiReg.extend([GridQubit(N+n_i+1,j) for j in range(L,2*L-1)])\n",
    "    n_aReg.extend([GridQubit(N+n_i+2,j) for j in range(L)])\n",
    "    w_aReg.extend([GridQubit(N+n_i+2,j) for j in range(L,2*L-1)])\n",
    "    n_bReg.extend([GridQubit(N+n_i+3,j) for j in range(L)])\n",
    "    w_bReg.extend([GridQubit(N+n_i+3,j) for j in range(L,2*L-1)])\n",
    "\n",
    "def intializeParticles(circuit, pReg, initialParticles):\n",
    "    \"\"\" Apply appropriate X gates to ensure that the p register contains all of the initial particles.\n",
    "        The p registers contains particles in the form of a list [LSB, middle bit, MSB]\"\"\"\n",
    "    for currentParticleIndex in range(len(initialParticles)):\n",
    "        for particleBit in range(3):\n",
    "            if initialParticles[currentParticleIndex][particleBit] == 1:\n",
    "                circuit.append(X(pReg[currentParticleIndex][particleBit]), strategy=early)\n",
    "\n",
    "\n",
    "def flavorControl(circuit, flavor, control, target, ancilla):\n",
    "    \"\"\"Controlled x onto targetQubit if \"control\" particle is of the correct flavor\"\"\"\n",
    "    if flavor == \"phi\":\n",
    "        circuit.append([X(control[1]), X(control[2])], strategy=new)\n",
    "        circuit.append(TOFFOLI(control[0], control[1], ancilla), strategy=new)\n",
    "        circuit.append(TOFFOLI(control[2], ancilla, target), strategy=new)\n",
    "        # undo work\n",
    "        circuit.append(TOFFOLI(control[0], control[1], ancilla), strategy=new)\n",
    "        circuit.append([X(control[1]), X(control[2])], strategy=new)\n",
    "    if flavor == \"a\":\n",
    "        circuit.append(X(control[0]), strategy=new)\n",
    "        circuit.append(TOFFOLI(control[0], control[2], target), strategy=new)\n",
    "        # undo work\n",
    "        circuit.append(X(control[0]), strategy=new)\n",
    "    if flavor == \"b\":\n",
    "        circuit.append(TOFFOLI(control[0], control[2], target), strategy=new)\n",
    "\n",
    "\n",
    "def plus1(circuit, l, countReg, workReg, control, ancilla, level):\n",
    "    \"\"\"\n",
    "    Recursively add 1 to the LSB of a register and carries to all bits, if control == 1\n",
    "    l: number of qubits in count register\n",
    "    countReg, workReg: count register and associated work register\n",
    "    control: control qubit to determine if plus1 should be executed\n",
    "    ancilla: extra work qubit\n",
    "    level: current qubit we are operating on, recursively travels from qubit 0 to l-1\n",
    "    \"\"\"\n",
    "    # apply X to LSB\n",
    "    if level == 0:\n",
    "        circuit.append(CNOT(control, countReg[0]), strategy=new)\n",
    "    if level < l - 1:\n",
    "        # first level uses CNOT instead of TOFFOLI gate\n",
    "        if level == 0:\n",
    "            # move all X gates to first step to avoid unnecesarry gates\n",
    "            circuit.append([X(qubit) for qubit in countReg], strategy=new)\n",
    "            circuit.append(TOFFOLI(countReg[0], control, workReg[0]), strategy=new)\n",
    "        else:\n",
    "            circuit.append(TOFFOLI(countReg[level], workReg[level - 1], ancilla), strategy=new)\n",
    "            circuit.append(TOFFOLI(ancilla, control, workReg[level]), strategy=new)\n",
    "            circuit.append(TOFFOLI(countReg[level], workReg[level - 1], ancilla), strategy=new)\n",
    "\n",
    "        circuit.append(TOFFOLI(workReg[level], control, countReg[level + 1]), strategy=new)\n",
    "        # recursively call next layer\n",
    "        plus1(circuit, l, countReg, workReg, control, ancilla, level + 1)\n",
    "        # undo work qubits (exact opposite of first 7 lines - undoes calculation)\n",
    "        if level == 0:\n",
    "            circuit.append(TOFFOLI(countReg[0], control, workReg[0]), strategy=new)\n",
    "            circuit.append([X(qubit) for qubit in countReg], strategy=new)\n",
    "        else:\n",
    "            circuit.append(TOFFOLI(countReg[level], workReg[level - 1], ancilla), strategy=new)\n",
    "            circuit.append(TOFFOLI(ancilla, control, workReg[level]), strategy=new)\n",
    "            circuit.append(TOFFOLI(countReg[level], workReg[level - 1], ancilla), strategy=new)\n",
    "\n",
    "def uCount(circuit, m, n_i, l, pReg, wReg, n_aReg, w_aReg, n_bReg, w_bReg, n_phiReg, w_phiReg):\n",
    "    \"\"\"\n",
    "    Populate the count registers using current particle states.\n",
    "    Uses wReg[0] as the control and wReg[1] as ancilla qubit for flavorControl and plus1, respectively\n",
    "    \"\"\"\n",
    "    for k in range(n_i+m):\n",
    "        # bosons\n",
    "        flavorControl(circuit, \"phi\", pReg[k], wReg[0], wReg[1])\n",
    "        plus1(circuit, l, n_phiReg, w_phiReg, wReg[0], wReg[1], 0)\n",
    "        flavorControl(circuit, \"phi\", pReg[k], wReg[0], wReg[1])\n",
    "        # a fermions\n",
    "        flavorControl(circuit, \"a\", pReg[k], wReg[0], wReg[1])\n",
    "        plus1(circuit, l, n_aReg, w_aReg, wReg[0], wReg[1], 0)\n",
    "        flavorControl(circuit, \"a\", pReg[k], wReg[0], wReg[1])\n",
    "        # b fermions\n",
    "        flavorControl(circuit, \"b\", pReg[k], wReg[0], wReg[1])\n",
    "        plus1(circuit, l, n_bReg, w_bReg, wReg[0], wReg[1], 0)\n",
    "        flavorControl(circuit, \"b\", pReg[k], wReg[0], wReg[1])\n",
    "\n",
    "def generateParticleCounts(n_i, m, k):\n",
    "    \"\"\"Fill countsList with all combinations of n_phi, n_a, and n_b where each n lies in range [0, n_i+m-k],\n",
    "    and the sum of all n's lies in range [n_i-k, m+n_i-k], all inclusive\n",
    "    \"\"\"\n",
    "    countsList = []\n",
    "    for numParticles in range(n_i-k, m+n_i-k+1):\n",
    "        for numPhi in range(0, n_i+m-k+1):\n",
    "            for numA in range(0, numParticles-numPhi+1):\n",
    "                numB = numParticles - numPhi - numA\n",
    "                countsList.append([numPhi, numA, numB])\n",
    "    return countsList\n",
    "\n",
    "def reverse(lst):\n",
    "    \"\"\"reverse a list in place\"\"\"\n",
    "    lst.reverse()\n",
    "    return lst\n",
    "\n",
    "def intToBinary(l, number):\n",
    "    \"\"\"Converts integer to binary list of size l with LSB first and MSB last\"\"\"\n",
    "    numberBinary = [int(x) for x in list('{0:0b}'.format(number))]\n",
    "    numberBinary = (l - len(numberBinary)) * [0] + numberBinary\n",
    "    return reverse(numberBinary)\n",
    "\n",
    "\n",
    "def numberControl(circuit, l, number, countReg, workReg):\n",
    "    \"\"\"\n",
    "    Applies an X to the l-2 (0 indexed) qubit of the work register if count register encodes the inputted number in binary\n",
    "    returns this l-2 qubit, unless l=1, in which case return the only count register qubit\n",
    "    DOES NOT CLEAN AFTER ITSELF - USE numberControlT to clean after this operation\n",
    "    \"\"\"\n",
    "    if type(number) == int:\n",
    "        numberBinary = intToBinary(l, number)\n",
    "    else:\n",
    "        numberBinary = number\n",
    "    circuit.append([X(countReg[i]) for i in range(len(numberBinary)) if numberBinary[i] == 0], strategy=new)\n",
    "    # first level does not use work qubits as control\n",
    "    if l > 1:\n",
    "        circuit.append(TOFFOLI(countReg[0], countReg[1], workReg[0]), strategy=new)\n",
    "        # subfunction to recursively handle toffoli gates\n",
    "\n",
    "    def binaryToffolis(level):\n",
    "        circuit.append(TOFFOLI(countReg[level], workReg[level - 2], workReg[level - 1]), strategy=new)\n",
    "        if level < l - 1:\n",
    "            binaryToffolis(level + 1)\n",
    "\n",
    "    if l > 2:\n",
    "        binaryToffolis(2)\n",
    "    # return qubit containing outcome of the operation\n",
    "    if l == 1:\n",
    "        return countReg[0]\n",
    "    else:\n",
    "        return workReg[l - 2]\n",
    "\n",
    "\n",
    "def numberControlT(circuit, l, number, countReg, workReg):\n",
    "    \"\"\"CLEANS AFTER numberControl operation\"\"\"\n",
    "    if type(number) == int:\n",
    "        numberBinary = intToBinary(l, number)\n",
    "    else:\n",
    "        numberBinary = number\n",
    "\n",
    "    # subfunction to recursively handle toffoli gates\n",
    "    def binaryToffolisT(level):\n",
    "        # circuit.append(TOFFOLI(countReg[level], workReg[level-2], workReg[level-1]), strategy=new)\n",
    "        if level < l:\n",
    "            binaryToffolisT(level + 1)\n",
    "            # undo\n",
    "            circuit.append(TOFFOLI(countReg[level], workReg[level - 2], workReg[level - 1]), strategy=new)\n",
    "\n",
    "    if l > 2:\n",
    "        binaryToffolisT(2)\n",
    "        # undo\n",
    "    if l > 1:\n",
    "        circuit.append(TOFFOLI(countReg[0], countReg[1], workReg[0]), strategy=new)\n",
    "        # undo\n",
    "    circuit.append([X(countReg[i]) for i in range(len(numberBinary)) if numberBinary[i] == 0], strategy=new)\n",
    "\n",
    "def uE(circuit, l, n_i, m, n_phiReg, w_phiReg, n_aReg, w_aReg, n_bReg, w_bReg, wReg, eReg, Delta_phi, Delta_a, Delta_b):\n",
    "    \"\"\"Determine if emission occured in current step m\"\"\"\n",
    "    countsList = generateParticleCounts(n_i, m, 0)\n",
    "\n",
    "    for counts in countsList:\n",
    "        n_phi, n_a, n_b = counts[0], counts[1], counts[2]\n",
    "        Delta = Delta_phi**n_phi * Delta_a**n_a * Delta_b**n_b\n",
    "        phiControlQub= numberControl(circuit, l, n_phi, n_phiReg, w_phiReg)\n",
    "        aControlQub = numberControl(circuit, l, n_a, n_aReg, w_aReg)\n",
    "        bControlQub = numberControl(circuit, l, n_b, n_bReg, w_bReg)\n",
    "        circuit.append(TOFFOLI(phiControlQub, aControlQub, wReg[0]), strategy=new)\n",
    "        circuit.append(TOFFOLI(bControlQub, wReg[0], wReg[1]), strategy=new)\n",
    "        circuit.append(ry(2*math.acos(np.sqrt(Delta))).controlled().on(wReg[1], eReg[0]))\n",
    "        #undo\n",
    "        circuit.append(TOFFOLI(bControlQub, wReg[0], wReg[1]), strategy=new)\n",
    "        circuit.append(TOFFOLI(phiControlQub, aControlQub, wReg[0]), strategy=new)\n",
    "        numberControlT(circuit, l, n_b, n_bReg, w_bReg)\n",
    "        numberControlT(circuit, l, n_a, n_aReg, w_aReg)\n",
    "        numberControlT(circuit, l, n_phi, n_phiReg, w_phiReg)\n",
    "\n",
    "\n",
    "def generateGrayList(l, number):\n",
    "    \"\"\"\n",
    "    l is the size of the current count register\n",
    "    Return list of elements in gray code from |0> to |number> where each entry is of type[int, binary list].\n",
    "    int: which bit is the target in the current iteration, binary list: the state of the rest of the qubits (controls)\n",
    "    \"\"\"\n",
    "    grayList = [[0, l * [0]]]\n",
    "    targetBinary = intToBinary(l, number)\n",
    "    for index in range(len(targetBinary)):\n",
    "        if targetBinary[index] == 1:\n",
    "            grayList.append([index, (list(grayList[-1][1]))])\n",
    "            grayList[-1][1][index] = 1\n",
    "    return grayList[1:]\n",
    "\n",
    "\n",
    "def twoLevelControlledRy(circuit, l, angle, k, externalControl, reg, workReg):\n",
    "    \"\"\"\n",
    "    Implements two level Ry rotation from state |0> to |k>, if externalControl qubit is on\n",
    "    for reference: http://www.physics.udel.edu/~msafrono/650/Lecture%206.pdf\n",
    "    \"\"\"\n",
    "    grayList = generateGrayList(l, k)\n",
    "    # handle the case where l=0 or 1\n",
    "    if k==0:\n",
    "        return\n",
    "    if l == 1 and k == 1:\n",
    "        circuit.append(cirq.ry(angle).controlled().on(externalControl, reg[0]))\n",
    "        return\n",
    "\n",
    "    # swap states according to Gray Code until one step before the end\n",
    "    for element in grayList:\n",
    "        targetQub = element[0]\n",
    "        number = element[1]\n",
    "        number = number[0:targetQub] + number[targetQub + 1:]\n",
    "        controlQub = numberControl(circuit, l - 1, number, reg[0:targetQub] + reg[targetQub + 1:], workReg)\n",
    "        if element == grayList[-1]:  # reached end\n",
    "            circuit.append(TOFFOLI(controlQub, externalControl, workReg[l - 2]), strategy=new)\n",
    "            circuit.append(cirq.ry(angle).controlled().on(workReg[l - 2], reg[targetQub]))\n",
    "            circuit.append(TOFFOLI(controlQub, externalControl, workReg[l - 2]), strategy=new)\n",
    "        else:  # swap states\n",
    "            circuit.append(CNOT(controlQub, reg[targetQub]), strategy=new)\n",
    "        numberControlT(circuit, l - 1, number, reg[0:targetQub] + reg[targetQub + 1:], workReg)\n",
    "\n",
    "    # undo\n",
    "    for element in reverse(grayList[:-1]):\n",
    "        targetQub = element[0]\n",
    "        number = element[1]\n",
    "        number = number[0:targetQub] + number[targetQub + 1:]\n",
    "        controlQub = numberControl(circuit, l - 1, number, reg[0:targetQub] + reg[targetQub + 1:], workReg)\n",
    "        circuit.append(CNOT(controlQub, reg[targetQub]), strategy=new)\n",
    "        numberControlT(circuit, l - 1, number, reg[0:targetQub] + reg[targetQub + 1:], workReg)\n",
    "    return\n",
    "\n",
    "def U_hAngle(flavor, n_phi, n_a, n_b, P_phi, P_a, P_b):\n",
    "    \"\"\"Determine angle of rotation used in U_h\"\"\"\n",
    "    denominator = n_phi * P_phi + n_a * P_a + n_b * P_b\n",
    "    if denominator == 0: # occurs if we are trying the case of no particles remaining (n_a = n_b = n_phi = 0)\n",
    "        return 0\n",
    "    flavorStringToP = {'phi': P_phi, 'a': P_a, 'b': P_b}\n",
    "    emissionAmplitude = np.sqrt(flavorStringToP[flavor] / denominator)\n",
    "    # correct for arcsin input greater than 1 errors for various input combinations that are irrelevant anyway\n",
    "    emissionAmplitude = min(1, emissionAmplitude)\n",
    "    return 2 * np.arcsin(emissionAmplitude)\n",
    "\n",
    "\n",
    "def minus1(circuit, l, countReg, workReg, control, ancilla, level):\n",
    "    \"\"\"\n",
    "    Recursively carries an subtraction of 1 to the LSB of a register to all bits if control == 1\n",
    "    Equivalent to plus1 but with an X applied to all count qubits before and after gate\n",
    "    \"\"\"\n",
    "    circuit.append([X(qubit) for qubit in countReg], strategy=new)\n",
    "    plus1(circuit, l, countReg, workReg, control, ancilla, level)\n",
    "    circuit.append([X(qubit) for qubit in countReg], strategy=new)\n",
    "\n",
    "\n",
    "def U_h(circuit, l, n_i, m, n_phiReg, w_phiReg, n_aReg, w_aReg, n_bReg, w_bReg, wReg, eReg, pReg, hReg, w_hReg, P_phi,\n",
    "        P_a, P_b):\n",
    "    \"\"\"Implement U_h from paper\"\"\"\n",
    "    for k in range(n_i + m):\n",
    "        countsList = generateParticleCounts(n_i, m, k)  # reduce the available number of particles\n",
    "        for counts in countsList:\n",
    "            n_phi, n_a, n_b = counts[0], counts[1], counts[2]\n",
    "            # controlled R-y from |0> to |k> on all qubits with all possible angles depending on n_phi, n_a, n_b, and flavor\n",
    "            for flavor in ['phi', 'a', 'b']:\n",
    "                angle = U_hAngle(flavor, n_phi, n_a, n_b, P_phi, P_a, P_b)\n",
    "                phiControl = numberControl(circuit, l, n_phi, n_phiReg, w_phiReg)\n",
    "                aControl = numberControl(circuit, l, n_a, n_aReg, w_aReg)\n",
    "                bControl = numberControl(circuit, l, n_b, n_bReg, w_bReg)\n",
    "                circuit.append(TOFFOLI(phiControl, aControl, wReg[0]), strategy=new)\n",
    "                circuit.append(TOFFOLI(bControl, wReg[0], wReg[1]), strategy=new)\n",
    "                flavorControl(circuit, flavor, pReg[k], wReg[2], wReg[4]) # wReg[4] is work qubit but is reset to 0\n",
    "                circuit.append(TOFFOLI(wReg[1], wReg[2], wReg[3]), strategy=new)\n",
    "                circuit.append(TOFFOLI(eReg[0], wReg[3], wReg[4]), strategy=new)\n",
    "\n",
    "                twoLevelControlledRy(circuit, l, angle, k+1, wReg[4], hReg[m], w_hReg)\n",
    "\n",
    "                circuit.append(TOFFOLI(eReg[0], wReg[3], wReg[4]), strategy=new)  # next steps undo work qubits\n",
    "                circuit.append(TOFFOLI(wReg[1], wReg[2], wReg[3]), strategy=new)\n",
    "                flavorControl(circuit, flavor, pReg[k], wReg[2], wReg[4])\n",
    "                circuit.append(TOFFOLI(bControl, wReg[0], wReg[1]), strategy=new)\n",
    "                circuit.append(TOFFOLI(phiControl, aControl, wReg[0]), strategy=new)\n",
    "                numberControlT(circuit, l, n_b, n_bReg, w_bReg)\n",
    "                numberControlT(circuit, l, n_a, n_aReg, w_aReg)\n",
    "                numberControlT(circuit, l, n_phi, n_phiReg, w_phiReg)\n",
    "\n",
    "        # subtract from the counts register depending on which flavor particle emitted\n",
    "        for flavor, countReg, workReg in zip(['phi', 'a', 'b'], [n_phiReg, n_aReg, n_bReg], [w_phiReg, w_aReg, w_bReg]):\n",
    "            flavorControl(circuit, flavor, pReg[k], wReg[0], wReg[1])\n",
    "            minus1(circuit, l, countReg, workReg, wReg[0], wReg[1], 0)\n",
    "            flavorControl(circuit, flavor, pReg[k], wReg[0], wReg[1])\n",
    "\n",
    "    # apply x on eReg if hReg[m] = 0, apply another x so we essentially control on not 0 instead of 0\n",
    "    isZeroControl = numberControl(circuit, l, 0, hReg[m], w_hReg)\n",
    "    circuit.append(CNOT(isZeroControl, eReg[0]))\n",
    "    circuit.append(X(eReg[0]), strategy=new)\n",
    "    numberControlT(circuit, l, 0, hReg[m], w_hReg)\n",
    "\n",
    "def updateParticles(circuit, l, n_i, m, k, pReg, wReg, controlQub, g_a, g_b):\n",
    "    \"\"\"Updates particle if controlQub is on\"\"\"\n",
    "    oldParticleReg = pReg[k]\n",
    "    newParticleReg = pReg[n_i+m]\n",
    "    #first gate in paper U_p\n",
    "    circuit.append(TOFFOLI(controlQub, oldParticleReg[2], newParticleReg[0]), strategy=new)\n",
    "    #second gate in paper (undoes work register immediately)\n",
    "    circuit.append([X(oldParticleReg[1]), X(oldParticleReg[2])], strategy=new)\n",
    "    circuit.append(TOFFOLI(controlQub, oldParticleReg[2], wReg[0]), strategy=new)\n",
    "    circuit.append(TOFFOLI(wReg[0], oldParticleReg[1], wReg[1]), strategy=new)\n",
    "    circuit.append(TOFFOLI(wReg[1], oldParticleReg[0], newParticleReg[2]), strategy=new)\n",
    "    circuit.append(TOFFOLI(wReg[0], oldParticleReg[1], wReg[1]), strategy=new)\n",
    "    circuit.append(TOFFOLI(controlQub, oldParticleReg[2], wReg[0]), strategy=new)\n",
    "    circuit.append([X(oldParticleReg[1]), X(oldParticleReg[2])], strategy=new)\n",
    "    #third gate in paper\n",
    "    circuit.append(TOFFOLI(controlQub, newParticleReg[2], oldParticleReg[2]), strategy=new)\n",
    "    #fourth and fifth gate in paper (then undoes work register)\n",
    "    circuit.append(TOFFOLI(controlQub, newParticleReg[2], wReg[0]), strategy=new)\n",
    "    circuit.append(cirq.H.controlled().on(wReg[0], newParticleReg[1]))\n",
    "    angle = (2 * np.arccos(g_a/np.sqrt(g_a**2 + g_b**2)))\n",
    "    circuit.append(cirq.ry(angle).controlled().on(wReg[0], newParticleReg[0]))\n",
    "    circuit.append(TOFFOLI(controlQub, newParticleReg[2], wReg[0]), strategy=new)\n",
    "    #sixth and seventh gate in paper (then undoes work register)\n",
    "    circuit.append([X(newParticleReg[0]), X(newParticleReg[1])], strategy=new)\n",
    "    circuit.append(TOFFOLI(newParticleReg[1], newParticleReg[2], wReg[0]), strategy=new)\n",
    "    circuit.append(TOFFOLI(controlQub, wReg[0], oldParticleReg[1]), strategy=new)\n",
    "    circuit.append(TOFFOLI(newParticleReg[1], newParticleReg[2], wReg[0]), strategy=new)\n",
    "    circuit.append(TOFFOLI(newParticleReg[0], newParticleReg[2], wReg[0]), strategy=new)\n",
    "    circuit.append(TOFFOLI(controlQub, wReg[0], oldParticleReg[0]), strategy=new)\n",
    "    circuit.append(TOFFOLI(newParticleReg[0], newParticleReg[2], wReg[0]), strategy=new)\n",
    "    circuit.append([X(newParticleReg[0]), X(newParticleReg[1])], strategy=new)\n",
    "\n",
    "def U_p(circuit, l, n_i, m, pReg, hReg, w_hReg, wReg, g_a, g_b):\n",
    "    \"\"\"Applies U_p from paper\"\"\"\n",
    "    for k in range(0, n_i + m):\n",
    "        controlQub = numberControl(circuit, l, k+1, hReg[m], w_hReg)\n",
    "        updateParticles(circuit, l, n_i, m, k, pReg, wReg, controlQub, g_a, g_b)\n",
    "        numberControlT(circuit, l, k+1, hReg[m], w_hReg)\n",
    "\n",
    "\n",
    "def createCircuit(n_i, N, eps, g_1, g_2, g_12, initialParticles):\n",
    "    \"\"\"\n",
    "    Create full circuit with n_i initial particles and N steps\n",
    "    Inputs:\n",
    "    n_i: number of initial particles\n",
    "    N: number of steps\n",
    "    eps, g_1, g_2, g_12: pre-chosen qft parameters\n",
    "    initialParticles: list of initial particles, each particle in a binary list of qubits [MSB middle bit, LSB]\n",
    "    (opposite order of the paper pg 6 - e.g a f_a fermion is [0,0,1])\n",
    "    in order [particle 1, particle 2, ..... particle n_i]\n",
    "    \"\"\"\n",
    "    # calculate constants\n",
    "    gp = math.sqrt(abs((g_1 - g_2) ** 2 + 4 * g_12 ** 2))\n",
    "    if g_1 > g_2:\n",
    "        gp = -gp\n",
    "    g_a, g_b = (g_1 + g_2 - gp) / 2, (g_1 + g_2 + gp) / 2\n",
    "    u = math.sqrt(abs((gp + g_1 - g_2)/ (2 * gp)))\n",
    "    \n",
    "    L = int(math.floor(math.log(N + n_i, 2)) + 1)\n",
    "\n",
    "    # evaluate P(Theta) and Delta(Theta) at every time step\n",
    "    timeStepList, P_aList, P_bList, P_phiList, Delta_aList, Delta_bList, Delta_phiList = [], [], [], [], [], [], []\n",
    "    populateParameterLists(N, timeStepList, P_aList, P_bList, P_phiList, Delta_aList, Delta_bList, Delta_phiList, g_a,\n",
    "                           g_b, eps)\n",
    "\n",
    "    # allocate and populate registers\n",
    "    pReg, hReg, w_hReg, eReg, wReg, n_aReg, w_aReg, n_bReg, w_bReg, n_phiReg, w_phiReg = [], [], [], [], [], [], [], [], [], [], []\n",
    "    allocateQubs(N, n_i, L, pReg, hReg, w_hReg, eReg, wReg, n_aReg, w_aReg, n_bReg, w_bReg, n_phiReg, w_phiReg)\n",
    "    qubits = {'pReg': pReg, 'hReg': hReg, 'w_hReg': w_hReg, 'eReg': eReg, 'wReg': wReg, 'n_aReg': n_aReg,\n",
    "               'w_aReg': w_aReg, 'n_bReg': n_bReg, 'w_bReg': w_bReg, 'n_phiReg': n_phiReg, 'w_phiReg': w_phiReg}\n",
    "\n",
    "    # create circuit object and initialize particles\n",
    "    circuit = cirq.Circuit()\n",
    "    intializeParticles(circuit, pReg, initialParticles)\n",
    "\n",
    "    # begin stepping through subcircuits\n",
    "    for m in range(N):\n",
    "        l = int(math.floor(math.log(m + n_i, 2)) + 1)\n",
    "\n",
    "        # R^(m) - rotate every particle p_k from 1,2 to a,b basis (step 1)\n",
    "        for p_k in pReg:\n",
    "            circuit.append(ry(2*math.asin(-u)).controlled().on(p_k[2], p_k[0]))\n",
    "\n",
    "        # populate count register (step 2)\n",
    "        uCount(circuit, m, n_i, l, pReg, wReg, n_aReg, w_aReg, n_bReg, w_bReg, n_phiReg, w_phiReg)\n",
    "\n",
    "        # assess if emmision occured (step 3)\n",
    "        uE(circuit, l, n_i, m, n_phiReg, w_phiReg, n_aReg, w_aReg, n_bReg, w_bReg, wReg, eReg,\n",
    "           Delta_phiList[m], Delta_aList[m], Delta_bList[m])\n",
    "\n",
    "        # choose a particle to split (step 4)\n",
    "        U_h(circuit, l, n_i, m, n_phiReg, w_phiReg, n_aReg, w_aReg, n_bReg, w_bReg, wReg, eReg, pReg, hReg, w_hReg,\n",
    "            P_phiList[m], P_aList[m], P_bList[m])\n",
    "\n",
    "        # update particle based on which particle split/emmitted (step 5)\n",
    "        U_p(circuit, l, n_i, m, pReg, hReg, w_hReg, wReg, g_a, g_b)\n",
    "\n",
    "        # R^-(m) rotate every particle p_k from a,b to 1,2 basis (step 6)\n",
    "        for p_k in pReg:\n",
    "            circuit.append(ry(2*math.asin(u)).controlled().on(p_k[2], p_k[0]))\n",
    "    \n",
    "    print('generated circuit on', len(flatten(list(qubits.values()))), 'qubits') \n",
    "\n",
    "    return circuit, qubits"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Testing using dirac_notation for quantum states."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### We start by breaking down one-step evolution (First run all cells from the beginning until 'Testing')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "#initial particle state\n",
    "def createCircuit1(n_i, N, eps, g_1, g_2, g_12, initialParticles):\n",
    "    \"\"\"\n",
    "    Create full circuit with n_i initial particles and N steps\n",
    "    Inputs:\n",
    "    n_i: number of initial particles\n",
    "    N: number of steps\n",
    "    eps, g_1, g_2, g_12: pre-chosen qft parameters\n",
    "    initialParticles: list of initial particles, each particle in a binary list of qubits [MSB middle bit, LSB]\n",
    "    (opposite order of the paper pg 6 - e.g a f_a fermion is [0,0,1])\n",
    "    in order [particle 1, particle 2, ..... particle n_i]\n",
    "    \"\"\"\n",
    "    # calculate constants\n",
    "    gp = math.sqrt(abs((g_1 - g_2) ** 2 + 4 * g_12 ** 2))\n",
    "    if g_1 > g_2:\n",
    "        gp = -gp\n",
    "    g_a, g_b = (g_1 + g_2 - gp) / 2, (g_1 + g_2 + gp) / 2\n",
    "    u = math.sqrt(abs((gp + g_1 - g_2)/ (2 * gp)))\n",
    "    \n",
    "    L = int(math.floor(math.log(N + n_i, 2)) + 1)\n",
    "\n",
    "    # evaluate P(Theta) and Delta(Theta) at every time step\n",
    "    timeStepList, P_aList, P_bList, P_phiList, Delta_aList, Delta_bList, Delta_phiList = [], [], [], [], [], [], []\n",
    "    populateParameterLists(N, timeStepList, P_aList, P_bList, P_phiList, Delta_aList, Delta_bList, Delta_phiList, g_a,\n",
    "                           g_b, eps)\n",
    "\n",
    "    # allocate and populate registers\n",
    "    pReg, hReg, w_hReg, eReg, wReg, n_aReg, w_aReg, n_bReg, w_bReg, n_phiReg, w_phiReg = [], [], [], [], [], [], [], [], [], [], []\n",
    "    allocateQubs(N, n_i, L, pReg, hReg, w_hReg, eReg, wReg, n_aReg, w_aReg, n_bReg, w_bReg, n_phiReg, w_phiReg)\n",
    "    qubits = {'pReg': pReg, 'hReg': hReg, 'w_hReg': w_hReg, 'eReg': eReg, 'wReg': wReg, 'n_aReg': n_aReg,\n",
    "               'w_aReg': w_aReg, 'n_bReg': n_bReg, 'w_bReg': w_bReg, 'n_phiReg': n_phiReg, 'w_phiReg': w_phiReg}\n",
    "\n",
    "    # create circuit object and initialize particles\n",
    "    circuit = cirq.Circuit()\n",
    "    intializeParticles(circuit, pReg, initialParticles)\n",
    "    \n",
    "    for p_k in pReg:\n",
    "        circuit.append([cirq.I(p_k[0]), cirq.I(p_k[1]), cirq.I(p_k[2])])\n",
    "    for h_k in pReg:\n",
    "        circuit.append([cirq.I(h_k[0]), cirq.I(h_k[1])])\n",
    "\n",
    "    circuit.append(cirq.I(w_hReg[0]))\n",
    "    circuit.append(cirq.I(eReg[0]))\n",
    "    circuit.append([cirq.I(wReg[0]), cirq.I(wReg[1]), cirq.I(wReg[2]), cirq.I(wReg[3]), cirq.I(wReg[4])])\n",
    "    circuit.append([cirq.I(n_aReg[0]), cirq.I(n_aReg[1])])\n",
    "    circuit.append(cirq.I(w_aReg[0]))                \n",
    "    circuit.append([cirq.I(n_bReg[0]), cirq.I(n_bReg[1])])\n",
    "    circuit.append(cirq.I(w_bReg[0]))\n",
    "    circuit.append([cirq.I(n_phiReg[0]), cirq.I(n_phiReg[1])])\n",
    "    circuit.append(cirq.I(w_phiReg[0]))\n",
    "    \n",
    "     \n",
    "\n",
    "    return circuit, qubits\n",
    "\n",
    "#rotate to f_a/b basis and count partilces\n",
    "def createCircuit2(n_i, N, eps, g_1, g_2, g_12, initialParticles):\n",
    "    \"\"\"\n",
    "    Create full circuit with n_i initial particles and N steps\n",
    "    Inputs:\n",
    "    n_i: number of initial particles\n",
    "    N: number of steps\n",
    "    eps, g_1, g_2, g_12: pre-chosen qft parameters\n",
    "    initialParticles: list of initial particles, each particle in a binary list of qubits [MSB middle bit, LSB]\n",
    "    (opposite order of the paper pg 6 - e.g a f_a fermion is [0,0,1])\n",
    "    in order [particle 1, particle 2, ..... particle n_i]\n",
    "    \"\"\"\n",
    "    # calculate constants\n",
    "    gp = math.sqrt(abs((g_1 - g_2) ** 2 + 4 * g_12 ** 2))\n",
    "    if g_1 > g_2:\n",
    "        gp = -gp\n",
    "    g_a, g_b = (g_1 + g_2 - gp) / 2, (g_1 + g_2 + gp) / 2\n",
    "    u = math.sqrt(abs((gp + g_1 - g_2)/ (2 * gp)))\n",
    "    \n",
    "    L = int(math.floor(math.log(N + n_i, 2)) + 1)\n",
    "\n",
    "    # evaluate P(Theta) and Delta(Theta) at every time step\n",
    "    timeStepList, P_aList, P_bList, P_phiList, Delta_aList, Delta_bList, Delta_phiList = [], [], [], [], [], [], []\n",
    "    populateParameterLists(N, timeStepList, P_aList, P_bList, P_phiList, Delta_aList, Delta_bList, Delta_phiList, g_a,\n",
    "                           g_b, eps)\n",
    "\n",
    "    # allocate and populate registers\n",
    "    pReg, hReg, w_hReg, eReg, wReg, n_aReg, w_aReg, n_bReg, w_bReg, n_phiReg, w_phiReg = [], [], [], [], [], [], [], [], [], [], []\n",
    "    allocateQubs(N, n_i, L, pReg, hReg, w_hReg, eReg, wReg, n_aReg, w_aReg, n_bReg, w_bReg, n_phiReg, w_phiReg)\n",
    "    qubits = {'pReg': pReg, 'hReg': hReg, 'w_hReg': w_hReg, 'eReg': eReg, 'wReg': wReg, 'n_aReg': n_aReg,\n",
    "               'w_aReg': w_aReg, 'n_bReg': n_bReg, 'w_bReg': w_bReg, 'n_phiReg': n_phiReg, 'w_phiReg': w_phiReg}\n",
    "\n",
    "    # create circuit object and initialize particles\n",
    "    circuit = cirq.Circuit()\n",
    "    intializeParticles(circuit, pReg, initialParticles)\n",
    "    \n",
    "    for p_k in pReg:\n",
    "        circuit.append([cirq.I(p_k[0]), cirq.I(p_k[1]), cirq.I(p_k[2])], strategy=new)\n",
    "    for h_k in pReg:\n",
    "        circuit.append([cirq.I(h_k[0]), cirq.I(h_k[1])], strategy=new)\n",
    "\n",
    "    circuit.append(cirq.I(w_hReg[0]), strategy=new)\n",
    "    circuit.append(cirq.I(eReg[0]), strategy=new)\n",
    "    circuit.append([cirq.I(wReg[0]), cirq.I(wReg[1]), cirq.I(wReg[2]), cirq.I(wReg[3]), cirq.I(wReg[4])], strategy=new)\n",
    "    circuit.append([cirq.I(n_aReg[0]), cirq.I(n_aReg[1])], strategy=new)\n",
    "    circuit.append(cirq.I(w_aReg[0]), strategy=new)                \n",
    "    circuit.append([cirq.I(n_bReg[0]), cirq.I(n_bReg[1])], strategy=new)\n",
    "    circuit.append(cirq.I(w_bReg[0]), strategy=new)\n",
    "    circuit.append([cirq.I(n_phiReg[0]), cirq.I(n_phiReg[1])], strategy=new)\n",
    "    circuit.append(cirq.I(w_phiReg[0]), strategy=new)\n",
    "    \n",
    "    \n",
    "\n",
    "    # begin stepping through subcircuits\n",
    "    for m in range(N):\n",
    "        l = int(math.floor(math.log(m + n_i, 2)) + 1)\n",
    "\n",
    "        # R^(m) - rotate every particle p_k from 1,2 to a,b basis (step 1)\n",
    "        for p_k in pReg:\n",
    "            circuit.append(ry(2*math.asin(-u)).controlled().on(p_k[2], p_k[0]))\n",
    "\n",
    "        # populate count register (step 2)\n",
    "        uCount(circuit, m, n_i, l, pReg, wReg, n_aReg, w_aReg, n_bReg, w_bReg, n_phiReg, w_phiReg)\n",
    "\n",
    "    return circuit, qubits\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "#rotate, count and emission operations\n",
    "def createCircuit3(n_i, N, eps, g_1, g_2, g_12, initialParticles):\n",
    "    \"\"\"\n",
    "    Create full circuit with n_i initial particles and N steps\n",
    "    Inputs:\n",
    "    n_i: number of initial particles\n",
    "    N: number of steps\n",
    "    eps, g_1, g_2, g_12: pre-chosen qft parameters\n",
    "    initialParticles: list of initial particles, each particle in a binary list of qubits [MSB middle bit, LSB]\n",
    "    (opposite order of the paper pg 6 - e.g a f_a fermion is [0,0,1])\n",
    "    in order [particle 1, particle 2, ..... particle n_i]\n",
    "    \"\"\"\n",
    "    # calculate constants\n",
    "    gp = math.sqrt(abs((g_1 - g_2) ** 2 + 4 * g_12 ** 2))\n",
    "    if g_1 > g_2:\n",
    "        gp = -gp\n",
    "    g_a, g_b = (g_1 + g_2 - gp) / 2, (g_1 + g_2 + gp) / 2\n",
    "    u = math.sqrt(abs((gp + g_1 - g_2)/ (2 * gp)))\n",
    "    \n",
    "    L = int(math.floor(math.log(N + n_i, 2)) + 1)\n",
    "\n",
    "    # evaluate P(Theta) and Delta(Theta) at every time step\n",
    "    timeStepList, P_aList, P_bList, P_phiList, Delta_aList, Delta_bList, Delta_phiList = [], [], [], [], [], [], []\n",
    "    populateParameterLists(N, timeStepList, P_aList, P_bList, P_phiList, Delta_aList, Delta_bList, Delta_phiList, g_a,\n",
    "                           g_b, eps)\n",
    "\n",
    "    # allocate and populate registers\n",
    "    pReg, hReg, w_hReg, eReg, wReg, n_aReg, w_aReg, n_bReg, w_bReg, n_phiReg, w_phiReg = [], [], [], [], [], [], [], [], [], [], []\n",
    "    allocateQubs(N, n_i, L, pReg, hReg, w_hReg, eReg, wReg, n_aReg, w_aReg, n_bReg, w_bReg, n_phiReg, w_phiReg)\n",
    "    qubits = {'pReg': pReg, 'hReg': hReg, 'w_hReg': w_hReg, 'eReg': eReg, 'wReg': wReg, 'n_aReg': n_aReg,\n",
    "               'w_aReg': w_aReg, 'n_bReg': n_bReg, 'w_bReg': w_bReg, 'n_phiReg': n_phiReg, 'w_phiReg': w_phiReg}\n",
    "\n",
    "    # create circuit object and initialize particles\n",
    "    circuit = cirq.Circuit()\n",
    "    intializeParticles(circuit, pReg, initialParticles)\n",
    "    \n",
    "    for p_k in pReg:\n",
    "        circuit.append([cirq.I(p_k[0]), cirq.I(p_k[1]), cirq.I(p_k[2])], strategy=new)\n",
    "    for h_k in pReg:\n",
    "        circuit.append([cirq.I(h_k[0]), cirq.I(h_k[1])], strategy=new)\n",
    "\n",
    "    circuit.append(cirq.I(w_hReg[0]), strategy=new)\n",
    "    circuit.append(cirq.I(eReg[0]), strategy=new)\n",
    "    circuit.append([cirq.I(wReg[0]), cirq.I(wReg[1]), cirq.I(wReg[2]), cirq.I(wReg[3]), cirq.I(wReg[4])], strategy=new)\n",
    "    circuit.append([cirq.I(n_aReg[0]), cirq.I(n_aReg[1])], strategy=new)\n",
    "    circuit.append(cirq.I(w_aReg[0]), strategy=new)                \n",
    "    circuit.append([cirq.I(n_bReg[0]), cirq.I(n_bReg[1])], strategy=new)\n",
    "    circuit.append(cirq.I(w_bReg[0]), strategy=new)\n",
    "    circuit.append([cirq.I(n_phiReg[0]), cirq.I(n_phiReg[1])], strategy=new)\n",
    "    circuit.append(cirq.I(w_phiReg[0]), strategy=new)\n",
    "    \n",
    "\n",
    "    # begin stepping through subcircuits\n",
    "    for m in range(N):\n",
    "        l = int(math.floor(math.log(m + n_i, 2)) + 1)\n",
    "\n",
    "        # R^(m) - rotate every particle p_k from 1,2 to a,b basis (step 1)\n",
    "        for p_k in pReg:\n",
    "            circuit.append(ry(2*math.asin(-u)).controlled().on(p_k[2], p_k[0]))\n",
    "\n",
    "        # populate count register (step 2)\n",
    "        uCount(circuit, m, n_i, l, pReg, wReg, n_aReg, w_aReg, n_bReg, w_bReg, n_phiReg, w_phiReg)\n",
    "\n",
    "        # assess if emmision occured (step 3)\n",
    "        uE(circuit, l, n_i, m, n_phiReg, w_phiReg, n_aReg, w_aReg, n_bReg, w_bReg, wReg, eReg,\n",
    "           Delta_phiList[m], Delta_aList[m], Delta_bList[m])\n",
    "\n",
    "        \n",
    "\n",
    "    return circuit, qubits\n",
    "\n",
    "\n",
    "# rotate, count, emission, history and particle adjust operation\n",
    "# (all operations but not roate back)\n",
    "def createCircuit4(n_i, N, eps, g_1, g_2, g_12, initialParticles):\n",
    "    \"\"\"\n",
    "    Create full circuit with n_i initial particles and N steps\n",
    "    Inputs:\n",
    "    n_i: number of initial particles\n",
    "    N: number of steps\n",
    "    eps, g_1, g_2, g_12: pre-chosen qft parameters\n",
    "    initialParticles: list of initial particles, each particle in a binary list of qubits [MSB middle bit, LSB]\n",
    "    (opposite order of the paper pg 6 - e.g a f_a fermion is [0,0,1])\n",
    "    in order [particle 1, particle 2, ..... particle n_i]\n",
    "    \"\"\"\n",
    "    # calculate constants\n",
    "    gp = math.sqrt(abs((g_1 - g_2) ** 2 + 4 * g_12 ** 2))\n",
    "    if g_1 > g_2:\n",
    "        gp = -gp\n",
    "    g_a, g_b = (g_1 + g_2 - gp) / 2, (g_1 + g_2 + gp) / 2\n",
    "    u = math.sqrt(abs((gp + g_1 - g_2)/ (2 * gp)))\n",
    "    \n",
    "    L = int(math.floor(math.log(N + n_i, 2)) + 1)\n",
    "\n",
    "    # evaluate P(Theta) and Delta(Theta) at every time step\n",
    "    timeStepList, P_aList, P_bList, P_phiList, Delta_aList, Delta_bList, Delta_phiList = [], [], [], [], [], [], []\n",
    "    populateParameterLists(N, timeStepList, P_aList, P_bList, P_phiList, Delta_aList, Delta_bList, Delta_phiList, g_a,\n",
    "                           g_b, eps)\n",
    "\n",
    "    # allocate and populate registers\n",
    "    pReg, hReg, w_hReg, eReg, wReg, n_aReg, w_aReg, n_bReg, w_bReg, n_phiReg, w_phiReg = [], [], [], [], [], [], [], [], [], [], []\n",
    "    allocateQubs(N, n_i, L, pReg, hReg, w_hReg, eReg, wReg, n_aReg, w_aReg, n_bReg, w_bReg, n_phiReg, w_phiReg)\n",
    "    qubits = {'pReg': pReg, 'hReg': hReg, 'w_hReg': w_hReg, 'eReg': eReg, 'wReg': wReg, 'n_aReg': n_aReg,\n",
    "               'w_aReg': w_aReg, 'n_bReg': n_bReg, 'w_bReg': w_bReg, 'n_phiReg': n_phiReg, 'w_phiReg': w_phiReg}\n",
    "\n",
    "    # create circuit object and initialize particles\n",
    "    circuit = cirq.Circuit()\n",
    "    intializeParticles(circuit, pReg, initialParticles)\n",
    "    \n",
    "    for p_k in pReg:\n",
    "        circuit.append([cirq.I(p_k[0]), cirq.I(p_k[1]), cirq.I(p_k[2])], strategy=new)\n",
    "    for h_k in pReg:\n",
    "        circuit.append([cirq.I(h_k[0]), cirq.I(h_k[1])], strategy=new)\n",
    "\n",
    "    circuit.append(cirq.I(w_hReg[0]), strategy=new)\n",
    "    circuit.append(cirq.I(eReg[0]), strategy=new)\n",
    "    circuit.append([cirq.I(wReg[0]), cirq.I(wReg[1]), cirq.I(wReg[2]), cirq.I(wReg[3]), cirq.I(wReg[4])], strategy=new)\n",
    "    circuit.append([cirq.I(n_aReg[0]), cirq.I(n_aReg[1])], strategy=new)\n",
    "    circuit.append(cirq.I(w_aReg[0]), strategy=new)                \n",
    "    circuit.append([cirq.I(n_bReg[0]), cirq.I(n_bReg[1])], strategy=new)\n",
    "    circuit.append(cirq.I(w_bReg[0]), strategy=new)\n",
    "    circuit.append([cirq.I(n_phiReg[0]), cirq.I(n_phiReg[1])], strategy=new)\n",
    "    circuit.append(cirq.I(w_phiReg[0]), strategy=new)\n",
    "    \n",
    "\n",
    "    # begin stepping through subcircuits\n",
    "    for m in range(N):\n",
    "        l = int(math.floor(math.log(m + n_i, 2)) + 1)\n",
    "\n",
    "        # R^(m) - rotate every particle p_k from 1,2 to a,b basis (step 1)\n",
    "        for p_k in pReg:\n",
    "            circuit.append(ry(2*math.asin(-u)).controlled().on(p_k[2], p_k[0]))\n",
    "\n",
    "        # populate count register (step 2)\n",
    "        uCount(circuit, m, n_i, l, pReg, wReg, n_aReg, w_aReg, n_bReg, w_bReg, n_phiReg, w_phiReg)\n",
    "\n",
    "        # assess if emmision occured (step 3)\n",
    "        uE(circuit, l, n_i, m, n_phiReg, w_phiReg, n_aReg, w_aReg, n_bReg, w_bReg, wReg, eReg,\n",
    "           Delta_phiList[m], Delta_aList[m], Delta_bList[m])\n",
    "\n",
    "        # choose a particle to split (step 4)\n",
    "        U_h(circuit, l, n_i, m, n_phiReg, w_phiReg, n_aReg, w_aReg, n_bReg, w_bReg, wReg, eReg, pReg, hReg, w_hReg,\n",
    "            P_phiList[m], P_aList[m], P_bList[m])\n",
    "\n",
    "        # update particle based on which particle split/emmitted (step 5)\n",
    "        U_p(circuit, l, n_i, m, pReg, hReg, w_hReg, wReg, g_a, g_b)\n",
    "\n",
    "\n",
    "    return circuit, qubits\n",
    "\n",
    "\n",
    "def createCircuitFull(n_i, N, eps, g_1, g_2, g_12, initialParticles):\n",
    "    \"\"\"\n",
    "    Create full circuit with n_i initial particles and N steps\n",
    "    Inputs:\n",
    "    n_i: number of initial particles\n",
    "    N: number of steps\n",
    "    eps, g_1, g_2, g_12: pre-chosen qft parameters\n",
    "    initialParticles: list of initial particles, each particle in a binary list of qubits [MSB middle bit, LSB]\n",
    "    (opposite order of the paper pg 6 - e.g a f_a fermion is [0,0,1])\n",
    "    in order [particle 1, particle 2, ..... particle n_i]\n",
    "    \"\"\"\n",
    "    # calculate constants\n",
    "    gp = math.sqrt(abs((g_1 - g_2) ** 2 + 4 * g_12 ** 2))\n",
    "    if g_1 > g_2:\n",
    "        gp = -gp\n",
    "    g_a, g_b = (g_1 + g_2 - gp) / 2, (g_1 + g_2 + gp) / 2\n",
    "    u = math.sqrt(abs((gp + g_1 - g_2)/ (2 * gp)))\n",
    "    \n",
    "    L = int(math.floor(math.log(N + n_i, 2)) + 1)\n",
    "\n",
    "    # evaluate P(Theta) and Delta(Theta) at every time step\n",
    "    timeStepList, P_aList, P_bList, P_phiList, Delta_aList, Delta_bList, Delta_phiList = [], [], [], [], [], [], []\n",
    "    populateParameterLists(N, timeStepList, P_aList, P_bList, P_phiList, Delta_aList, Delta_bList, Delta_phiList, g_a,\n",
    "                           g_b, eps)\n",
    "\n",
    "    # allocate and populate registers\n",
    "    pReg, hReg, w_hReg, eReg, wReg, n_aReg, w_aReg, n_bReg, w_bReg, n_phiReg, w_phiReg = [], [], [], [], [], [], [], [], [], [], []\n",
    "    allocateQubs(N, n_i, L, pReg, hReg, w_hReg, eReg, wReg, n_aReg, w_aReg, n_bReg, w_bReg, n_phiReg, w_phiReg)\n",
    "    qubits = {'pReg': pReg, 'hReg': hReg, 'w_hReg': w_hReg, 'eReg': eReg, 'wReg': wReg, 'n_aReg': n_aReg,\n",
    "               'w_aReg': w_aReg, 'n_bReg': n_bReg, 'w_bReg': w_bReg, 'n_phiReg': n_phiReg, 'w_phiReg': w_phiReg}\n",
    "\n",
    "    # create circuit object and initialize particles\n",
    "    circuit = cirq.Circuit()\n",
    "    intializeParticles(circuit, pReg, initialParticles)\n",
    "    \n",
    "    for p_k in pReg:\n",
    "        circuit.append([cirq.I(p_k[0]), cirq.I(p_k[1]), cirq.I(p_k[2])], strategy=new)\n",
    "    for h_k in pReg:\n",
    "        circuit.append([cirq.I(h_k[0]), cirq.I(h_k[1])], strategy=new)\n",
    "\n",
    "    circuit.append(cirq.I(w_hReg[0]), strategy=new)\n",
    "    circuit.append(cirq.I(eReg[0]), strategy=new)\n",
    "    circuit.append([cirq.I(wReg[0]), cirq.I(wReg[1]), cirq.I(wReg[2]), cirq.I(wReg[3]), cirq.I(wReg[4])], strategy=new)\n",
    "    circuit.append([cirq.I(n_aReg[0]), cirq.I(n_aReg[1])], strategy=new)\n",
    "    circuit.append(cirq.I(w_aReg[0]), strategy=new)                \n",
    "    circuit.append([cirq.I(n_bReg[0]), cirq.I(n_bReg[1])], strategy=new)\n",
    "    circuit.append(cirq.I(w_bReg[0]), strategy=new)\n",
    "    circuit.append([cirq.I(n_phiReg[0]), cirq.I(n_phiReg[1])], strategy=new)\n",
    "    circuit.append(cirq.I(w_phiReg[0]), strategy=new)\n",
    "    \n",
    "    \n",
    "    \n",
    "\n",
    "    # begin stepping through subcircuits\n",
    "    for m in range(N):\n",
    "        l = int(math.floor(math.log(m + n_i, 2)) + 1)\n",
    "\n",
    "        # R^(m) - rotate every particle p_k from 1,2 to a,b basis (step 1)\n",
    "        for p_k in pReg:\n",
    "            circuit.append(ry(2*math.asin(-u)).controlled().on(p_k[2], p_k[0]))\n",
    "\n",
    "        # populate count register (step 2)\n",
    "        uCount(circuit, m, n_i, l, pReg, wReg, n_aReg, w_aReg, n_bReg, w_bReg, n_phiReg, w_phiReg)\n",
    "\n",
    "        # assess if emmision occured (step 3)\n",
    "        uE(circuit, l, n_i, m, n_phiReg, w_phiReg, n_aReg, w_aReg, n_bReg, w_bReg, wReg, eReg,\n",
    "           Delta_phiList[m], Delta_aList[m], Delta_bList[m])\n",
    "\n",
    "        # choose a particle to split (step 4)\n",
    "        U_h(circuit, l, n_i, m, n_phiReg, w_phiReg, n_aReg, w_aReg, n_bReg, w_bReg, wReg, eReg, pReg, hReg, w_hReg,\n",
    "            P_phiList[m], P_aList[m], P_bList[m])\n",
    "\n",
    "        # update particle based on which particle split/emmitted (step 5)\n",
    "        U_p(circuit, l, n_i, m, pReg, hReg, w_hReg, wReg, g_a, g_b)\n",
    "\n",
    "        # R^-(m) rotate every particle p_k from a,b to 1,2 basis (step 6)\n",
    "        for p_k in pReg:\n",
    "            circuit.append(ry(2*math.asin(u)).controlled().on(p_k[2], p_k[0]))\n",
    "    \n",
    "    print('generated circuit on', len(flatten(list(qubits.values()))), 'qubits') \n",
    "\n",
    "    return circuit, qubits"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "The Dirac notation for the final state is:\n",
      " |0010000000000000000000⟩\n"
     ]
    }
   ],
   "source": [
    "## inputs are: createCircuit(n_i, N, eps, g_1, g_2, g_12, [[0, 0, 1]])\n",
    "n_i, N = 1, 1\n",
    "g_1, g_2, g_12 = 2, 1, 1\n",
    "eps = .001\n",
    "reps = 30\n",
    "\n",
    "circuit1, qubits1 = createCircuit1(n_i, N, eps, g_1, g_2, g_12, [[0, 0, 1]])\n",
    "#print(circuit)\n",
    "\n",
    "simulator1 = cirq.Simulator()\n",
    "res1 = simulator1.simulate(circuit1)\n",
    "#print(\"The wavefunction of the final state is:\\n\",\n",
    "      #res.final_state_vector, end=\"\\n\")\n",
    "\n",
    "print(\"\\nThe Dirac notation for the final state is:\\n\",\n",
    "      res1.dirac_notation())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "The Dirac notation for the final state is:\n",
      " 0.85|0010000000000000100000⟩ - 0.53|1010000000000000000100⟩\n"
     ]
    }
   ],
   "source": [
    "### rotate to f_a/b basis and count partilces\n",
    "\n",
    "## inputs are: createCircuit(n_i, N, eps, g_1, g_2, g_12, [[0, 0, 1]])\n",
    "n_i, N = 1, 1\n",
    "g_1, g_2, g_12 = 2, 1, 1\n",
    "eps = .001\n",
    "reps = 30\n",
    "\n",
    "circuit2, qubits2 = createCircuit2(n_i, N, eps, g_1, g_2, g_12, [[0, 0, 1]])\n",
    "#print(circuit)\n",
    "\n",
    "\n",
    "simulator2 = cirq.Simulator()\n",
    "res2 = simulator2.simulate(circuit2)\n",
    "#print(\"The wavefunction of the final state is:\\n\",\n",
    "      #res.final_state_vector, end=\"\\n\")\n",
    "\n",
    "print(\"\\nThe Dirac notation for the final state is:\\n\",\n",
    "      res2.dirac_notation())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "The Dirac notation for the final state is:\n",
      " 0.13|0010000000000000100000⟩ + 0.84|0010000100000000100000⟩ - 0.51|1010000000000000000100⟩ - 0.15|1010000100000000000100⟩\n"
     ]
    }
   ],
   "source": [
    "#### rotate, count and emission operations\n",
    "\n",
    "## inputs are: createCircuit(n_i, N, eps, g_1, g_2, g_12, [[0, 0, 1]])\n",
    "n_i, N = 1, 1\n",
    "g_1, g_2, g_12 = 2, 1, 1\n",
    "eps = .001\n",
    "reps = 30\n",
    "\n",
    "circuit3, qubits3 = createCircuit3(n_i, N, eps, g_1, g_2, g_12, [[0, 0, 1]])\n",
    "#print(circuit)\n",
    "\n",
    "\n",
    "simulator3 = cirq.Simulator()\n",
    "res3 = simulator3.simulate(circuit3)\n",
    "#print(\"The wavefunction of the final state is:\\n\",\n",
    "      #res.final_state_vector, end=\"\\n\")\n",
    "\n",
    "print(\"\\nThe Dirac notation for the final state is:\\n\",\n",
    "      res3.dirac_notation())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "The Dirac notation for the final state is:\n",
      " 0.13|00100000000000000000000⟩ + 0.84|00111000000000000000000⟩ - 0.51|10100000000000000000000⟩ - 0.15|10111000000000000000000⟩\n"
     ]
    }
   ],
   "source": [
    "#### rotate, count, emission, history and particle adjust operation\n",
    "#### (all operations but not roate back)\n",
    "\n",
    "## inputs are: createCircuit(n_i, N, eps, g_1, g_2, g_12, [[0, 0, 1]])\n",
    "n_i, N = 1, 1\n",
    "g_1, g_2, g_12 = 2, 1, 1\n",
    "eps = .001\n",
    "reps = 30\n",
    "\n",
    "circuit4, qubits4 = createCircuit4(n_i, N, eps, g_1, g_2, g_12, [[0, 0, 1]])\n",
    "#print(circuit)\n",
    "\n",
    "\n",
    "\n",
    "simulator4 = cirq.Simulator()\n",
    "res4 = simulator4.simulate(circuit4)\n",
    "#print(\"The wavefunction of the final state is:\\n\",\n",
    "      #res.final_state_vector, end=\"\\n\")\n",
    "\n",
    "print(\"\\nThe Dirac notation for the final state is:\\n\",\n",
    "      res4.dirac_notation())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "generated circuit on 24 qubits\n",
      "\n",
      "The Dirac notation for the final state is:\n",
      " 0.38|00100000000000000000000⟩ + 0.79|00111000000000000000000⟩ - 0.36|10100000000000000000000⟩ + 0.32|10111000000000000000000⟩\n"
     ]
    }
   ],
   "source": [
    "### Full Circuit (with identities) ###\n",
    "\n",
    "## inputs are: createCircuit(n_i, N, eps, g_1, g_2, g_12, [[0, 0, 1]])\n",
    "n_i, N = 1, 1\n",
    "g_1, g_2, g_12 = 2, 1, 1\n",
    "eps = .001\n",
    "reps = 30\n",
    "\n",
    "circuit, qubits = createCircuitFull(n_i, N, eps, g_1, g_2, g_12, [[0, 0, 1]])\n",
    "#print(circuit)\n",
    "\n",
    "\n",
    "\n",
    "simulator = cirq.Simulator()\n",
    "res = simulator.simulate(circuit)\n",
    "#print(\"The wavefunction of the final state is:\\n\",\n",
    "      #res.final_state_vector, end=\"\\n\")\n",
    "\n",
    "print(\"\\nThe Dirac notation for the final state is:\\n\",\n",
    "      res.dirac_notation())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'pReg': [[cirq.GridQubit(0, 0), cirq.GridQubit(0, 1), cirq.GridQubit(0, 2)], [cirq.GridQubit(1, 0), cirq.GridQubit(1, 1), cirq.GridQubit(1, 2)]], 'hReg': [[cirq.GridQubit(0, 4), cirq.GridQubit(0, 5)]], 'w_hReg': [cirq.GridQubit(2, 0)], 'eReg': [cirq.GridQubit(2, 1)], 'wReg': [cirq.GridQubit(2, 2), cirq.GridQubit(2, 3), cirq.GridQubit(2, 4), cirq.GridQubit(2, 5), cirq.GridQubit(2, 6)], 'n_aReg': [cirq.GridQubit(4, 0), cirq.GridQubit(4, 1)], 'w_aReg': [cirq.GridQubit(4, 2)], 'n_bReg': [cirq.GridQubit(5, 0), cirq.GridQubit(5, 1)], 'w_bReg': [cirq.GridQubit(5, 2)], 'n_phiReg': [cirq.GridQubit(3, 0), cirq.GridQubit(3, 1)], 'w_phiReg': [cirq.GridQubit(3, 2)]}\n"
     ]
    }
   ],
   "source": [
    "print(qubits)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "colab": {
   "collapsed_sections": [],
   "machine_shape": "hm",
   "name": "PartonShower.ipynb",
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
